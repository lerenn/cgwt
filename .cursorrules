# Cursor Rules for WTM Project

## Testing Conventions

### Test Organization
- **Adapters** (like `pkg/fs`) should have **integration tests only** using real file system operations
- **Business Logic** (like `pkg/wtm`) should have **unit tests only** using mocked dependencies
- **End-to-End Tests** (in `test/` directory) should test the complete CLI workflow using real Git operations
- Use build tags to organize tests:
  - `//go:build unit` for unit tests with mocked dependencies
  - `//go:build integration` for integration tests with real file system
  - `//go:build e2e` for end-to-end tests with real CLI and Git operations

### Test File Naming
- Standard test files: `*_test.go` (for integration tests in adapters)
- Unit test files: `*_test.go` with `//go:build unit` tag
- Integration test files: `*_integration_test.go` with `//go:build integration` tag
- End-to-end test files: `*_test.go` with `//go:build e2e` tag in `test/` directory

### Mock Generation
- Use Uber gomock for mocking: `go.uber.org/mock v0.5.2`
- Generate mocks with: `//go:generate go run go.uber.org/mock/mockgen@v0.5.2`
- Mock files should be committed to repository as `*_gen.go`
- Keep mockgen parameters simple

### Test Structure
- Use `testify/assert` for assertions
- Use `gomock.NewController(t)` for mock setup
- Always clean up resources with `defer` statements
- Test both positive and negative cases
- Verify error messages and user output

### Error Testing Best Practices
- **ALWAYS use `assert.ErrorIs()` for checking specific errors** instead of `assert.Contains(t, err.Error(), "error message")`
- **NEVER use both `assert.Error(t, err)` and `assert.ErrorIs(t, err, specificError)`** - `assert.ErrorIs()` already checks that the error is not nil
- Create specific error variables in `*_errors.go` files for each error type
- Use `errors.New()` or `fmt.Errorf()` with `%w` to wrap errors with context
- Example:
  ```go
  // ✅ GOOD: Use specific errors with assert.ErrorIs()
  assert.ErrorIs(t, err, ErrGitRepositoryNotFound)
  
  // ❌ BAD: Don't use string matching with assert.Contains()
  assert.Contains(t, err.Error(), "not a valid Git repository: .git directory not found")
  
  // ❌ BAD: Don't use redundant error checking
  assert.Error(t, err)
  assert.ErrorIs(t, err, ErrGitRepositoryNotFound)
  ```
- Define errors in package-specific `errors.go` files:
  ```go
  // pkg/wtm/errors.go
  var ErrGitRepositoryNotFound = errors.New("not a valid Git repository: .git directory not found")
  ```

### What Constitutes an Adapter
- **Adapters**: Interfaces that abstract external systems (file system, network, databases)
- Examples: `pkg/fs` (file system operations), future network clients, database clients
- **Business Logic**: Core application logic that uses adapters
- Examples: `pkg/wtm` (Git repository detection logic)

### Running Tests
- Unit tests: `go test -tags=unit ./...`
- Integration tests: `go test -tags=integration ./...`
- End-to-end tests: `go test -tags=e2e ./test/`
- All tests: `go test ./...`

### Code Quality
- Follow Go best practices and conventions
- Use meaningful variable and function names
- Add comments for complex logic
- Handle errors properly with wrapped errors using `fmt.Errorf` with `%w`

## Shipping Process

When asked to "ship" the code or when shipping is mentioned, systematically execute these commands in order:

1. **Generate Code**: Execute `go generate ./...` to ensure all generated files are up to date
2. **Lint and Fix**: Execute `dagger call lint --source-dir=.` and automatically fix any linting errors that are found
3. **Unit tests**: Execute `dagger call unit-tests --source-dir .`  and automatically fix any errors that are found
4. **Integration tests**: Execute `dagger call integration-tests --source-dir .`  and automatically fix any errors that are found
5. **End-to-end tests**: Execute `dagger call end-to-end-tests --source-dir .`  and automatically fix any errors that are found
6. **Create Branch**: Create a new branch with a descriptive name based on the changes made ONLY if you're on main branch so check before hand.
7. **Commit Changes**: Commit all changes with a descriptive commit message following conventional commit format
8. **Push Branch**: Push the new branch to the remote repository

### Branch Naming Convention
- Use descriptive names like: `feat/add-new-feature`, `fix/resolve-linting-issues`, `docs/update-readme`
- Use kebab-case for branch names
- Include the type of change (feat, fix, docs, refactor, etc.)

### Commit Message Format
- Use conventional commit format: `type(scope): description`
- Examples: `feat(wtm): add git repository detection`, `fix(lint): resolve godot comment issues`
- Keep descriptions concise but descriptive
