# Cursor Rules for WTM Project

## Testing Conventions

### Test Organization
- **Adapters** (like `pkg/fs`) should have **integration tests only** using real file system operations
- **Business Logic** (like `pkg/wtm`) should have **unit tests only** using mocked dependencies
- **End-to-End Tests** (in `test/` directory) should test the complete workflow using the WTM struct directly with real Git operations
- Use build tags to organize tests:
  - `//go:build unit` for unit tests with mocked dependencies
  - `//go:build integration` for integration tests with real file system
  - `//go:build e2e` for end-to-end tests with real WTM struct and Git operations

### Test File Naming
- Standard test files: `*_test.go` (for integration tests in adapters)
- Unit test files: `*_test.go` with `//go:build unit` tag
- Integration test files: `*_integration_test.go` with `//go:build integration` tag
- End-to-end test files: `*_test.go` with `//go:build e2e` tag in `test/` directory

### Mock Generation
- Use Uber gomock for mocking: `go.uber.org/mock v0.5.2`
- Generate mocks with: `//go:generate go run go.uber.org/mock/mockgen@v0.5.2`
- Mock files should be committed to repository as `*_gen.go`
- Keep mockgen parameters simple

### Test Structure
- Use `testify/assert` for assertions
- Use `gomock.NewController(t)` for mock setup
- Always clean up resources with `defer` statements
- Test both positive and negative cases
- Verify error messages and user output

### System File Protection
- **NEVER impact system status and config files** (`~/.wtm/status.yaml`, `~/.wtm/config.yaml`) during testing or manual testing
- **ALWAYS create temporary directories** with all necessary files inside for testing
- Use `os.MkdirTemp()` to create isolated test environments
- Create temporary config files pointing to temporary directories
- **End-to-end tests should use WTM struct directly** with temporary config, not CLI commands
- Never use environment variables that could affect system configuration
- Always clean up temporary directories in test teardown
- **For manual testing in Cursor shell**: Always use `-c` flag with CLI commands to specify temporary config files
- Example pattern for end-to-end tests:
  ```go
  // ✅ GOOD: Create temporary test environment
  tempDir, err := os.MkdirTemp("", "wtm-test-*")
  require.NoError(t, err)
  defer os.RemoveAll(tempDir)
  
  // Create temporary config file
  configPath := filepath.Join(tempDir, "config.yaml")
  configData := fmt.Sprintf("base_path: %s\nstatus_file: %s\n", tempDir, filepath.Join(tempDir, "status.yaml"))
  require.NoError(t, os.WriteFile(configPath, []byte(configData), 0644))
  
  // Use WTM struct directly with temporary config
  wtmInstance := wtm.NewWTM(&config.Config{
      BasePath:   tempDir,
      StatusFile: filepath.Join(tempDir, "status.yaml"),
  })
  err = wtmInstance.CreateWorkTree("test-branch", nil)
  
  // ❌ BAD: Don't use environment variables that affect system
  os.Setenv("WTM_BASE_PATH", "/some/path")
  os.Setenv("WTM_STATUS_FILE", "/some/path/status.yaml")
  ```
- Example pattern for manual testing in Cursor shell:
  ```bash
  # ✅ GOOD: Use temporary config for manual testing
  tempDir=$(mktemp -d)
  echo "base_path: $tempDir" > "$tempDir/config.yaml"
  echo "status_file: $tempDir/status.yaml" >> "$tempDir/config.yaml"
  
  # Test with temporary config
  ./wtm -c "$tempDir/config.yaml" create test-branch
  
  # Clean up
  rm -rf "$tempDir"
  
  # ❌ BAD: Don't test without config flag (affects system files)
  ./wtm create test-branch
  ```

### Error Testing Best Practices
- **ALWAYS use `assert.ErrorIs()` for checking specific errors** instead of `assert.Contains(t, err.Error(), "error message")`
- **NEVER use both `assert.Error(t, err)` and `assert.ErrorIs(t, err, specificError)`** - `assert.ErrorIs()` already checks that the error is not nil
- Create specific error variables in `*_errors.go` files for each error type
- Use `errors.New()` or `fmt.Errorf()` with `%w` to wrap errors with context
- Example:
  ```go
  // ✅ GOOD: Use specific errors with assert.ErrorIs()
  assert.ErrorIs(t, err, ErrGitRepositoryNotFound)
  
  // ❌ BAD: Don't use string matching with assert.Contains()
  assert.Contains(t, err.Error(), "not a valid Git repository: .git directory not found")
  
  // ❌ BAD: Don't use redundant error checking
  assert.Error(t, err)
  assert.ErrorIs(t, err, ErrGitRepositoryNotFound)
  ```
- Define errors in package-specific `errors.go` files:
  ```go
  // pkg/wtm/errors.go
  var ErrGitRepositoryNotFound = errors.New("not a valid Git repository: .git directory not found")
  ```

### What Constitutes an Adapter
- **Adapters**: Interfaces that abstract external systems (file system, network, databases)
- Examples: `pkg/fs` (file system operations), future network clients, database clients
- **Business Logic**: Core application logic that uses adapters
- Examples: `pkg/wtm` (Git repository detection logic)

### Running Tests
- Unit tests: `go test -tags=unit ./...`
- Integration tests: `go test -tags=integration ./...`
- End-to-end tests: `go test -tags=e2e ./test/`
- All tests: `go test ./...`

### Code Quality
- Follow Go best practices and conventions
- Use meaningful variable and function names
- Add comments for complex logic
- Handle errors properly with wrapped errors using `fmt.Errorf` with `%w`

### CLI Architecture
- **CLI (`cmd/wtm/main.go`) should ONLY contain boilerplate code**:
  - Command definitions and flag parsing
  - Configuration loading
  - Basic argument validation (existence, count)
  - Calling WTM methods with parsed arguments
  - Displaying results
- **NO business logic in CLI**: All parsing, validation, and processing should be in the WTM package
- **WTM methods should be self-contained**: They should handle all internal parsing and validation
- **CLI should be thin**: Just pass arguments to WTM methods and display results
- Example:
  ```go
  // ✅ GOOD: CLI only handles basic parsing and calls WTM
  func createLoadCmd() *cobra.Command {
      return &cobra.Command{
          RunE: func(_ *cobra.Command, args []string) error {
              cfg := loadConfig()
              wtmManager := wtm.NewWTM(cfg)
              return wtmManager.LoadWorktree(args[0], ideName) // WTM handles all parsing
          },
      }
  }
  
  // ❌ BAD: CLI contains business logic
  func createLoadCmd() *cobra.Command {
      return &cobra.Command{
          RunE: func(_ *cobra.Command, args []string) error {
              // Business logic here - should be in WTM
              parts := strings.SplitN(args[0], ":", 2)
              // ... more parsing logic
          },
      }
  }
  ```

## Shipping Process

**IMPORTANT**: The shipping process should ONLY be executed when the user explicitly asks to "ship" the code or mentions shipping. Do NOT automatically execute the shipping process after implementing features.

When explicitly asked to "ship" the code or when shipping is mentioned, systematically execute these commands in order:

1. **Generate Code**: Execute `go generate ./...` to ensure all generated files are up to date
2. **Lint and Fix**: Execute `dagger call lint --source-dir=.` and automatically fix any linting errors that are found
3. **Unit tests**: Execute `dagger call unit-tests --source-dir .`  and automatically fix any errors that are found
4. **Integration tests**: Execute `dagger call integration-tests --source-dir .`  and automatically fix any errors that are found
5. **End-to-end tests**: Execute `dagger call end-to-end-tests --source-dir .`  and automatically fix any errors that are found
6. **Create Branch**: Create a new branch with a descriptive name based on the first request of the chat. ONLY if you're on main branch so check before hand.
7. **Commit Changes**: Commit all changes with a descriptive commit message where:
   - **Title**: Use the first request of the chat as the commit title following conventional commit format
   - **Description**: Use the complete summary of everything done in the chat as the commit description
8. **Push Branch**: Push the new branch to the remote repository

### Branch Naming Convention
- Use descriptive names like: `feat/add-new-feature`, `fix/resolve-linting-issues`, `docs/update-readme`
- Use kebab-case for branch names
- Include the type of change (feat, fix, docs, refactor, etc.)
- Base the branch name on the first request of the chat

### Commit Message Format
- **Title**: Use conventional commit format: `type(scope): description` based on the first request
- **Description**: Include the complete summary of all changes made throughout the chat
- Examples:
  ```
  feat(wtm): implement load command for remote branches
  
  - Created feature file for wtm load [remote-source:branch-name] command
  - Implemented LoadWorktree method in WTM package with remote parsing
  - Added remote management functionality (add/fetch/validate)
  - Refactored CLI to be boilerplate-only, moved business logic to WTM
  - Added comprehensive unit tests for all new functionality
  - Fixed SSH URL construction for remote addition
  - Updated list command to display remote names in brackets
  - Added proper error handling and validation
  - Updated .cursorrules to enforce CLI architecture patterns
  ```
