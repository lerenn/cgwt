# Cursor Rules for WTM Project

## Testing Conventions

### Test Organization
- **Adapters** (like `pkg/fs`) should have **integration tests only** using real file system operations
- **Business Logic** (like `pkg/wtm`) should have **unit tests only** using mocked dependencies
- **End-to-End Tests** (in `test/` directory) should test the complete workflow using the WTM struct directly with real Git operations
- Use build tags to organize tests:
  - `//go:build unit` for unit tests with mocked dependencies
  - `//go:build integration` for integration tests with real file system
  - `//go:build e2e` for end-to-end tests with real WTM struct and Git operations

### Test File Naming
- Standard test files: `*_test.go` (for integration tests in adapters)
- Unit test files: `*_test.go` with `//go:build unit` tag
- Integration test files: `*_integration_test.go` with `//go:build integration` tag
- End-to-end test files: `*_test.go` with `//go:build e2e` tag in `test/` directory

### Mock Generation
- Use Uber gomock for mocking: `go.uber.org/mock v0.5.2`
- Generate mocks with: `//go:generate go run go.uber.org/mock/mockgen@v0.5.2`
- Mock files should be committed to repository as `*_gen.go`
- Keep mockgen parameters simple

### Test Structure
- Use `testify/assert` for assertions
- Use `gomock.NewController(t)` for mock setup
- Always clean up resources with `defer` statements
- Test both positive and negative cases
- Verify error messages and user output

### System File Protection
- **NEVER impact system status and config files** (`~/.wtm/status.yaml`, `~/.wtm/config.yaml`) during testing or manual testing
- **ALWAYS create temporary directories** with all necessary files inside for testing
- Use `os.MkdirTemp()` to create isolated test environments
- Create temporary config files pointing to temporary directories
- **End-to-end tests should use WTM struct directly** with temporary config, not CLI commands
- Never use environment variables that could affect system configuration
- Always clean up temporary directories in test teardown
- **For manual testing in Cursor shell**: Always use `-c` flag with CLI commands to specify temporary config files
- Example pattern for end-to-end tests:
  ```go
  // ✅ GOOD: Create temporary test environment
  tempDir, err := os.MkdirTemp("", "wtm-test-*")
  require.NoError(t, err)
  defer os.RemoveAll(tempDir)
  
  // Create temporary config file
  configPath := filepath.Join(tempDir, "config.yaml")
  configData := fmt.Sprintf("base_path: %s\nstatus_file: %s\n", tempDir, filepath.Join(tempDir, "status.yaml"))
  require.NoError(t, os.WriteFile(configPath, []byte(configData), 0644))
  
  // Use WTM struct directly with temporary config
  wtmInstance := wtm.NewWTM(&config.Config{
      BasePath:   tempDir,
      StatusFile: filepath.Join(tempDir, "status.yaml"),
  })
  err = wtmInstance.CreateWorkTree("test-branch", nil)
  
  // ❌ BAD: Don't use environment variables that affect system
  os.Setenv("WTM_BASE_PATH", "/some/path")
  os.Setenv("WTM_STATUS_FILE", "/some/path/status.yaml")
  ```
- Example pattern for manual testing in Cursor shell:
  ```bash
  # ✅ GOOD: Use temporary config for manual testing
  tempDir=$(mktemp -d)
  echo "base_path: $tempDir" > "$tempDir/config.yaml"
  echo "status_file: $tempDir/status.yaml" >> "$tempDir/config.yaml"
  
  # Test with temporary config
  ./wtm -c "$tempDir/config.yaml" create test-branch
  
  # Clean up
  rm -rf "$tempDir"
  
  # ❌ BAD: Don't test without config flag (affects system files)
  ./wtm create test-branch
  ```

### Error Testing Best Practices
- **ALWAYS use `assert.ErrorIs()` for checking specific errors** instead of `assert.Contains(t, err.Error(), "error message")`
- **NEVER use both `assert.Error(t, err)` and `assert.ErrorIs(t, err, specificError)`** - `assert.ErrorIs()` already checks that the error is not nil
- Create specific error variables in `*_errors.go` files for each error type
- Use `errors.New()` or `fmt.Errorf()` with `%w` to wrap errors with context
- Example:
  ```go
  // ✅ GOOD: Use specific errors with assert.ErrorIs()
  assert.ErrorIs(t, err, ErrGitRepositoryNotFound)
  
  // ❌ BAD: Don't use string matching with assert.Contains()
  assert.Contains(t, err.Error(), "not a valid Git repository: .git directory not found")
  
  // ❌ BAD: Don't use redundant error checking
  assert.Error(t, err)
  assert.ErrorIs(t, err, ErrGitRepositoryNotFound)
  ```
- Define errors in package-specific `errors.go` files:
  ```go
  // pkg/wtm/errors.go
  var ErrGitRepositoryNotFound = errors.New("not a valid Git repository: .git directory not found")
  ```

### What Constitutes an Adapter
- **Adapters**: Interfaces that abstract external systems (file system, network, databases)
- Examples: `pkg/fs` (file system operations), future network clients, database clients
- **Business Logic**: Core application logic that uses adapters
- Examples: `pkg/wtm` (Git repository detection logic)

### Running Tests
- Unit tests: `go test -tags=unit ./...`
- Integration tests: `go test -tags=integration ./...`
- End-to-end tests: `go test -tags=e2e ./test/`
- All tests: `go test ./...`

### Code Quality
- Follow Go best practices and conventions
- Use meaningful variable and function names
- Add comments for complex logic
- Handle errors properly with wrapped errors using `fmt.Errorf` with `%w`

## Shipping Process

When asked to "ship" the code or when shipping is mentioned, systematically execute these commands in order:

1. **Generate Code**: Execute `go generate ./...` to ensure all generated files are up to date
2. **Lint and Fix**: Execute `dagger call lint --source-dir=.` and automatically fix any linting errors that are found
3. **Unit tests**: Execute `dagger call unit-tests --source-dir .`  and automatically fix any errors that are found
4. **Integration tests**: Execute `dagger call integration-tests --source-dir .`  and automatically fix any errors that are found
5. **End-to-end tests**: Execute `dagger call end-to-end-tests --source-dir .`  and automatically fix any errors that are found
6. **Create Branch**: Create a new branch with a descriptive name based on the changes made from the beginning of the chat, not only the last ones. ONLY if you're on main branch so check before hand.
7. **Commit Changes**: Commit all changes with a descriptive commit message following conventional commit format based on the changes made from the beginning of the chat, not only the last ones.
8. **Push Branch**: Push the new branch to the remote repository

### Branch Naming Convention
- Use descriptive names like: `feat/add-new-feature`, `fix/resolve-linting-issues`, `docs/update-readme`
- Use kebab-case for branch names
- Include the type of change (feat, fix, docs, refactor, etc.)

### Commit Message Format
- Use conventional commit format: `type(scope): description`
- Examples: `feat(wtm): add git repository detection`, `fix(lint): resolve godot comment issues`
- Keep descriptions concise but descriptive
