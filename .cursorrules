# Cursor Rules for CGWT Project

## Testing Conventions

### Test Organization
- **Adapters** (like `pkg/fs`) should have **integration tests only** using real file system operations
- **Business Logic** (like `pkg/cgwt`) should have **unit tests only** using mocked dependencies
- Use build tags to organize tests:
  - `//go:build unit` for unit tests with mocked dependencies
  - `//go:build integration` for integration tests with real file system

### Test File Naming
- Standard test files: `*_test.go` (for integration tests in adapters)
- Unit test files: `*_test.go` with `//go:build unit` tag
- Integration test files: `*_integration_test.go` with `//go:build integration` tag

### Mock Generation
- Use Uber gomock for mocking: `go.uber.org/mock v0.5.2`
- Generate mocks with: `//go:generate go run go.uber.org/mock/mockgen@v0.5.2`
- Mock files should be committed to repository as `*_gen.go`
- Keep mockgen parameters simple

### Test Structure
- Use `testify/assert` for assertions
- Use `gomock.NewController(t)` for mock setup
- Always clean up resources with `defer` statements
- Test both positive and negative cases
- Verify error messages and user output

### What Constitutes an Adapter
- **Adapters**: Interfaces that abstract external systems (file system, network, databases)
- Examples: `pkg/fs` (file system operations), future network clients, database clients
- **Business Logic**: Core application logic that uses adapters
- Examples: `pkg/cgwt` (Git repository detection logic)

### Running Tests
- Unit tests: `go test -tags=unit ./...`
- Integration tests: `go test -tags=integration ./...`
- All tests: `go test ./...`

### Code Quality
- Follow Go best practices and conventions
- Use meaningful variable and function names
- Add comments for complex logic
- Handle errors properly with wrapped errors using `fmt.Errorf` with `%w`

## Shipping Process

When asked to "ship" the code or when shipping is mentioned, systematically execute these commands in order:

1. **Generate Code**: Execute `go generate ./...` to ensure all generated files are up to date
2. **Lint and Fix**: Execute `dagger call lint --source-dir=.` and automatically fix any linting errors that are found
3. **Unit tests**: Execute `dagger call unit-tests --source-dir .`  and automatically fix any errors that are found
3. **Integration tests**: Execute `dagger call integration-tests --source-dir .`  and automatically fix any errors that are found
4. **Create Branch**: Create a new branch with a descriptive name based on the changes made
5. **Commit Changes**: Commit all changes with a descriptive commit message following conventional commit format
6. **Push Branch**: Push the new branch to the remote repository

### Branch Naming Convention
- Use descriptive names like: `feat/add-new-feature`, `fix/resolve-linting-issues`, `docs/update-readme`
- Use kebab-case for branch names
- Include the type of change (feat, fix, docs, refactor, etc.)

### Commit Message Format
- Use conventional commit format: `type(scope): description`
- Examples: `feat(cgwt): add git repository detection`, `fix(lint): resolve godot comment issues`
- Keep descriptions concise but descriptive
